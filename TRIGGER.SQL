/*  
    1- L'UTENTE DEVE ESSERE MAGGIORENNE
    TESTATO E FUNZIONANTE
*/
CREATE OR REPLACE TRIGGER VERIFICA_ETA_UTENTE
BEFORE INSERT ON UTENTE
FOR EACH ROW
DECLARE
    MINORENNE EXCEPTION;
BEGIN

    IF (SYSDATE - :NEW.DATA_DI_NASCITA) / 365.25 < 18 THEN
        RAISE MINORENNE;
    END IF;

EXCEPTION WHEN MINORENNE THEN
    RAISE_APPLICATION_ERROR(-1000,'ERRORE, DEVI AVERE ALMENO 18 ANNI!');

END VERIFICA_ETA_UTENTE;

/*
    2- ALL'INSERIMENTO DELLA CARTA, ESSA NON DEVE ESSERE SCADUTA
    TESTATO E FUNZIONANTE
*/
CREATE OR REPLACE TRIGGER VERIFICA_CARTA_SCADUTA
BEFORE INSERT OR UPDATE ON CARTA_DI_CREDITO
FOR EACH ROW
DECLARE
    CARTASCADUTA EXCEPTION;
BEGIN

    IF :NEW.DATA_DI_SCADENZA < SYSDATE THEN
        RAISE CARTASCADUTA;
    END IF;

EXCEPTION WHEN CARTASCADUTA THEN 
    RAISE_APPLICATION_ERROR(-2000,'ERRORE, CARTA SCADUTA!');

END VERIFICA_CARTA_SCADUTA;

/*  
    3- CONTROLLO SALDO MOVIMENTO PRELIEVO
    TESTATO E FUNZIONANTE
*/
CREATE OR REPLACE TRIGGER CONTROLLO_PRELIEVO
BEFORE INSERT ON MOVIMENTO
FOR EACH ROW
DECLARE
    SALDO_NON_SUFFICIENTE   EXCEPTION;
    SALDO   NUMBER := 0;
    CONTATORE NUMBER := 0;
BEGIN

    SELECT COUNT(*)
    INTO CONTATORE
    FROM MOVIMENTO
    WHERE ID_CONTO_VIRTUALE_M = :NEW.ID_CONTO_VIRTUALE_M AND NOME_PIATTAFORMA_M = :NEW.NOME_PIATTAFORMA_M;

    IF CONTATORE > 0 AND :NEW.TIPO_MOVIMENTO = 2 THEN

        SALDO := SALDOVAL(:NEW.ID_CONTO_VIRTUALE_M,:NEW.NOME_PIATTAFORMA_M);

        IF :NEW.QUANTITA_M > SALDO THEN
            RAISE SALDO_NON_SUFFICIENTE;
        END IF;
    -- NEL CASO IN CUI NON CI SIA NESSUNA TUPLA IN MOVIMENTO E SI VUOLE PRELEVARE    
    ELSIF :NEW.TIPO_MOVIMENTO = 2 THEN
        RAISE SALDO_NON_SUFFICIENTE;

    END IF;

    EXCEPTION WHEN SALDO_NON_SUFFICIENTE THEN
        RAISE_APPLICATION_ERROR(-3000,'ERRORE, SALDO INSUFFICIENTE!');

END CONTROLLO_PRELIEVO;

/*  
    4- LA DATA DELLA REWARDS DEVE ESSERE SUCCESSIVA ALLA DATA DI CREAZIONE DEL CONTO VIRTUALE
    TESTATO E FUNZIONANTE
*/
CREATE OR REPLACE TRIGGER CONTROLLO_DATA_REWARDS
BEFORE INSERT ON REWARDS
FOR EACH ROW
DECLARE
    DATA_NON_ACCETTATA EXCEPTION;
    DATACREAZIONE      DATE;
BEGIN

    SELECT DATA_CREAZIONE
    INTO DATACREAZIONE
    FROM CONTO_VIRTUALE
    WHERE ID_CONTO_VIRTUALE = :NEW.ID_CONTO_VIRTUALE_R AND NOME_PIATTAFORMA_CV = :NEW.NOME_PIATTAFORMA_R;

    IF DATACREAZIONE != NULL THEN
        IF :NEW.DATA_RILASCIO < DATACREAZIONE THEN
            RAISE   DATA_NON_ACCETTATA;
        END IF;
    END IF;

    EXCEPTION WHEN DATA_NON_ACCETTATA THEN
        RAISE_APPLICATION_ERROR(-4000,'ERRORE, IL CONTO NON ESISTE!');
END CONTROLLO_DATA_REWARDS;

/*
    5- ALL'INSERIMENTO DELLA CARTA NEL CONTO VIRTUALE ESSA DEVE ESISTERE
    TESTATO E FUNZIONANTE
*/
CREATE OR REPLACE TRIGGER CONTROLLO_ESISTENZA_CARTA
BEFORE INSERT ON COLLEGATO
FOR EACH ROW
DECLARE
    NON_ESISTE  EXCEPTION;
    NCARTA      CHAR(16);
BEGIN

    SELECT NUMERO_CARTA
    INTO NCARTA
    FROM CARTA_DI_CREDITO
    WHERE NUMERO_CARTA = :NEW.NUMERO_CARTA_C;

    IF NCARTA IS NULL THEN
        RAISE NON_ESISTE;
    END IF;

    EXCEPTION WHEN NON_ESISTE THEN
        RAISE_APPLICATION_ERROR(-5000,'ERRORE, CARTA INESISTENTE!');

END CONTROLLO_ESISTENZA_CARTA;

/*  
    6- TRIGGER CHE CONTROLLA SE, ALL'INSERIMENTO DI UN CONTO COLLEGTO AL CONTO VIRTUALE, TUTTE LE CARTE COLLEGATE AD ESSO SIANO DELLO STESSO UTENTE
    TESTATO E FUNZIONANTE
*/
CREATE OR REPLACE TRIGGER VERIFICA_CARTE_SU_CONTO_VIRTUALE
BEFORE INSERT ON COLLEGATO
FOR EACH ROW
DECLARE
    PIU_UTENTI  EXCEPTION;
    NCARTA      CHAR(16);
    CFUTENTE    CHAR(16);
BEGIN

    SELECT CF_UTENTE
    INTO CFUTENTE
    FROM CARTA_DI_CREDITO
    WHERE NUMERO_CARTA = :NEW.NUMERO_CARTA_C;

    FOR i IN (
        SELECT CF_UTENTE
        FROM CARTA_DI_CREDITO
        WHERE NUMERO_CARTA IN (
            SELECT NUMERO_CARTA_C
            FROM COLLEGATO
            WHERE ID_CONTO_VIRTUALE_C = :NEW.ID_CONTO_VIRTUALE_C AND NOME_PIATTAFORMA_C = :NEW.NOME_PIATTAFORMA_C
        )
    )
    LOOP
        IF CFUTENTE != i.CF_UTENTE THEN
            RAISE PIU_UTENTI;
        END IF;
    END LOOP;

    EXCEPTION WHEN PIU_UTENTI THEN
        RAISE_APPLICATION_ERROR(-6000,'ERRORE, CARTE COLLEGATE A PIU DI UNA PERSONA!');

END VERIFICA_CARTE_SU_CONTO_VIRTUALE; 

/*  
    7- AL COMPIERE DI UN MOVIMENTO IL NUMERO DELLA CARTA DEVE ESSERE COLLEGATO AL CONTO VIRTUALE
    TESTATO E FUNZIONANTE
*/
CREATE OR REPLACE TRIGGER CONTROLLO_METODO_DI_PAGAMENTO
BEFORE INSERT ON MOVIMENTO
FOR EACH ROW
DECLARE
    NON_PRESENTE EXCEPTION;
    CONTAT NUMBER := 0;
BEGIN

    SELECT COUNT(NUMERO_CARTA_C)
    INTO CONTAT
    FROM COLLEGATO
    WHERE :NEW.ID_CONTO_VIRTUALE_M = ID_CONTO_VIRTUALE_C AND NOME_PIATTAFORMA_C = :NEW.NOME_PIATTAFORMA_M AND :NEW.NUMERO_CARTA_M = NUMERO_CARTA_C;

    IF CONTAT < 1 THEN
        RAISE NON_PRESENTE;
    END IF;

    EXCEPTION WHEN NON_PRESENTE THEN
        RAISE_APPLICATION_ERROR(-7000,'IL METODO DI PAGAMENTO NON RISULTA COLLEGATO AL CONTO VIRTUALE');

END CONTROLLO_METODO_DI_PAGAMENTO;

/*
    8- ALL'INSERIMENTO DI SCAMBIO CONTROLLA SE IL DEX DAL QUALE SI EFFETTUA SIA COLLEGATO AD UN WALLET IL QAULE E' ASSOCIATO AL CONTO VIRTUALE DAL QUALE SI EFFETTUA LO SCAMBIO
*/
CREATE OR REPLACE TRIGGER CONTROLLO_SCAMBIO
BEFORE INSERT ON SCAMBIO
FOR EACH ROW
DECLARE
    NON_COLLEGATO EXCEPTION;
    CONTA NUMBER := 0;
BEGIN

    SELECT COUNT(*)
    INTO CONTA
    FROM UNITO
    WHERE NOME_EXCHANGE_U = :NEW.NOME_EXCHANGE_DEX AND INDIRIZZO_U IN (
        SELECT INDIRIZZO_A
        FROM ASSOCIATO
        WHERE ID_CONTO_VIRTUALE_A = :NEW.ID_CONTO_VIRTUALE_S AND NOME_PIATTAFORMA_A = :NEW.NOME_PIATTAFORMA_S
    );

    IF CONTA < 1 THEN
        RAISE NON_COLLEGATO;
    END IF;

    EXCEPTION WHEN NON_COLLEGATO THEN
        RAISE_APPLICATION_ERROR(-8000,'QUESTO SCAMBIO NON PUO ESSERE EFFETTUATO');

END CONTROLLO_SCAMBIO;

/*
    9- TRIGGER PER CONFERMARE LA DISPONIBILITA' SUL CONTO PER EFFETTUARE LO SCAMBIO
*/
CREATE OR REPLACE TRIGGER EFFETTUA_SCAMBIO
BEFORE INSERT ON SCAMBIO
FOR EACH ROW
DECLARE
    SALDO_INSUFFICIENTE EXCEPTION;
    SALDOSCAMBIOCRYPTO NUMBER := 0;
    SALDO NUMBER := 0;
BEGIN

    IF :NEW.VALUTA_OTTENUTA = 'EUR' OR :NEW.VALUTA_SCAMBIATA = 'EUR' THEN
        SALDO := SALDOVAL(:NEW.ID_CONTO_VIRTUALE_S,:NEW.NOME_PIATTAFORMA_S);
    ELSE 
        SALDO := SALDOCRYPTO(:NEW.ID_CONTO_VIRTUALE_S,:NEW.NOME_PIATTAFORMA_S,:NEW.VALUTA_SCAMBIATA);
    END IF;

    DBMS_OUTPUT.PUT_LINE('SALDO: ' || SALDO);

    IF SALDO < :NEW.QUANTITA_SCAMBIATA THEN
        RAISE SALDO_INSUFFICIENTE;
    END IF;

    EXCEPTION WHEN SALDO_INSUFFICIENTE THEN
        RAISE_APPLICATION_ERROR(-9000,'SALDO INSUFFICIENTE!');

END EFFETTUA_SCAMBIO;
/*
    FUNCTION CHE RESTITUISCE IL SALDO DELLA VALUTA SETTATA NEL CONTO VIRTUALE
*/
CREATE OR REPLACE FUNCTION SALDOVAL(IDCONTOVIRTUALE IN VARCHAR,NOMEPIATTAFORMA IN VARCHAR)
RETURN NUMBER
IS
    SALDO NUMBER := 0;
    SALDO_VAL_MOV NUMBER := 0;
    SALDO_VAL_SCA NUMBER := 0;
BEGIN

    FOR i IN (
        SELECT *
        FROM MOVIMENTO
        WHERE ID_CONTO_VIRTUALE_M = IDCONTOVIRTUALE AND NOME_PIATTAFORMA_M = NOMEPIATTAFORMA
        ORDER BY DATA_M ASC
    )
    LOOP
        IF i.TIPO_MOVIMENTO = 1 THEN
            SALDO_VAL_MOV := SALDO_VAL_MOV + (i.QUANTITA_M - i.FEE_M);
        ELSE 
            SALDO_VAL_MOV := SALDO_VAL_MOV - (i.QUANTITA_M - i.FEE_M);
        END IF;
    END LOOP;

    FOR j IN (
        SELECT *
        FROM SCAMBIO
        WHERE ID_CONTO_VIRTUALE_S = IDCONTOVIRTUALE AND NOME_PIATTAFORMA_S = NOMEPIATTAFORMA
        ORDER BY DATA_S ASC
    )
    LOOP
        IF j.VALUTA_OTTENUTA = 'EUR' THEN 
            SALDO_VAL_SCA := SALDO_VAL_SCA + (j.QUANTITA_OTTENUTA - j.FFE_S);
        ELSIF j.VALUTA_SCAMBIATA = 'EUR' THEN
            SALDO_VAL_SCA := SALDO_VAL_SCA - (j.QUANTITA_SCAMBIATA - j.FFE_S);
        END IF;
    END LOOP;
    SALDO := SALDO_VAL_MOV + SALDO_VAL_SCA;

    DBMS_OUTPUT.PUT_LINE('SALDO FUNCTION IN EUR:' || SALDO);
    RETURN SALDO;

END SALDOVAL;
/*
    FUNCTION CHE RESTITUISCE IL SALDO DELLA CRYPTO CHE DEVE ESSERE SCAMBIATA
*/
CREATE OR REPLACE FUNCTION SALDOCRYPTO(IDCONTOVIRTUALE IN VARCHAR,NOMEPIATTAFORMA IN VARCHAR,VALUTA IN VARCHAR)
RETURN NUMBER
IS
    SALDO NUMBER := 0;
    SALDO_VAL_REW NUMBER := 0;
    SALDO_VAL_SCA NUMBER := 0;
BEGIN

    FOR k IN (
        SELECT *
        FROM SCAMBIO
        WHERE (VALUTA_SCAMBIATA = VALUTA OR VALUTA_OTTENUTA = VALUTA) AND ID_CONTO_VIRTUALE_S = IDCONTOVIRTUALE AND NOME_PIATTAFORMA_S = NOMEPIATTAFORMA
    )
    LOOP
        IF k.VALUTA_OTTENUTA = VALUTA THEN
            SALDO_VAL_SCA := SALDO_VAL_SCA + (k.QUANTITA_OTTENUTA - k.FFE_S);
        ELSE 
            SALDO_VAL_SCA := SALDO_VAL_SCA - (k.QUANTITA_SCAMBIATA - k.FFE_S);
        END IF;
    END LOOP;
    
    FOR i IN (
        SELECT *
        FROM REWARDS
        WHERE NOME_R = VALUTA AND ID_CONTO_VIRTUALE_R = IDCONTOVIRTUALE AND NOME_PIATTAFORMA_R = NOMEPIATTAFORMA AND DATA_RILASCIO > SYSDATE+1
    )
    LOOP
        SALDO_VAL_REW := SALDO_VAL_REW + i.QUANTITA_R;
    END LOOP;

    SALDO := SALDO_VAL_SCA + SALDO_VAL_REW;

    DBMS_OUTPUT.PUT_LINE('SALDO FUNCTION CRYPTO IN ' || VALUTA || ': ' || SALDO);
    RETURN SALDO;

END SALDOCRYPTO;